<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>گزارش بصری ماه‌های قمری</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<style>
		body {
			font-family: sans-serif;
			background-color: #f0f2f5;
			color: #333;
		}
		.container {
			max-width: 1200px;
			margin: 2rem auto;
			padding: 1.5rem;
			background-color: #ffffff;
			border-radius: 0.75rem;
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
		}
		table {
			width: 100%;
			border-collapse: separate;
			border-spacing: 0;
			overflow: hidden;
		}
		th, td {
			padding: 0.4rem;
			text-align: center;
			border: 1px solid #e2e8f0;
			font-size: 0.75rem;
		}
		th {
			background-color: #4a90e2;
			color: white;
			font-weight: 600;
			position: sticky;
			top: 0;
			z-index: 10;
		}
		td {
			background-color: #ffffff;
		}
		/* رنگ برای ماه‌های دارای داده تکی (قرمز کمرنگ - کمترین دقت) */
		.highlighted {
			background-color: #FFCCCC;
			font-weight: 500;
		}
		/* رنگ برای ماه‌های متوالی (نارنجی - دقت متوسط) */
		.consecutive-highlighted {
			background-color: #FFA500; /* نارنجی */
			font-weight: 500;
			color: white;
		}
		/* رنگ برای ماه‌های میانی در توالی‌های حداقل سه‌تایی (سبز - دقت بالا) */
		.inner-consecutive-highlighted {
			background-color: #090; /* سبز */
			font-weight: 500;
			color: white;
		}
		/* رنگ برای ماه‌هایی که تاریخ‌های آن همدیگر را تأیید می‌کنند (آبی فیروزه‌ای - دقت بسیار بالا) */
		.confirmed-highlighted {
			background-color: #00FFFF; /* آبی فیروزه‌ای */
			font-weight: 500;
			color: black; /* متن سیاه برای خوانایی بهتر */
		}
		/* رنگ برای ماه‌هایی که هم متوالی هستند و هم تأیید شده‌اند (آبی سیر - بالاترین دقت) */
		.confirmed-and-inner-consecutive-highlighted {
			background-color: #00008B; /* آبی سیر */
			font-weight: 500;
			color: white;
		}
		.scroll-container {
			max-height: 400px;
			overflow-y: auto;
			border-radius: 0.75rem;
			border: 1px solid #e2e8f0;
		}
		canvas {
			border: 1px solid #e2e8f0;
			display: block;
			margin: 1rem auto;
			image-rendering: pixelated; /* Ensures sharp pixels */
			max-width: 100%; /* Make canvas responsive */
			height: auto; /* Maintain aspect ratio */
		}
	</style>
</head>
<body class="p-4">
	<div class="container">
		<h1 class="text-3xl font-bold text-center mb-6 text-blue-700">گزارش بصری ماه‌های قمری</h1>

		<textarea
			id="dataInput"
			class="w-full h-40 p-4 mb-6 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-right"
			placeholder="داده‌های خود را اینجا وارد کنید (مثال: YYYY-MM-DD)..."
			onkeyup="generateReport()"
		>0504-02-15	شنبه
0504-03-01	یکشنبه
0504-04-10	دوشنبه
0504-05-01	سه‌شنبه
0504-06-01	چهارشنبه
0528-04-23	دوشنبه
0528-05-05	سه‌شنبه
0529-07-01	پنجشنبه
0536-11-15	پنجشنبه
0536-12-01	جمعه
0537-01-01	شنبه
0915-03-05	یکشنبه
0915-03-10	جمعه
</textarea>

		<div id="summaryContainer" class="text-center mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
		</div>

		<canvas id="dataCanvas" width="400" height="384"></canvas>

		<h2 class="text-2xl font-bold text-center mb-4 text-blue-600 mt-8">جدول جزئیات ماه‌ها</h2>
		<div id="reportContainer" class="scroll-container">
		</div>
	</div>

	<script>
		// یک نگاشت برای تبدیل نام روز به عدد (0 برای شنبه تا 6 برای جمعه)
		const dayOfWeekMap = {
			'شنبه': 0,
			'یکشنبه': 1,
			'دوشنبه': 2,
			'سه‌شنبه': 3,
			'چهارشنبه': 4,
			'پنجشنبه': 5,
			'جمعه': 6
		};

		/**
		 * منطق تأیید روز هفته برای تاریخ‌های یک ماه مشخص
		 * @param {Array<Object>} monthData - آرایه‌ای از اشیاء {day, dayOfWeek}
		 * @returns {boolean} - اگر تاریخ‌ها همدیگر را تأیید کنند، true و در غیر این صورت false
		 */
		function checkMonthForConfirmation(monthData) {
			// اگر کمتر از دو تاریخ در ماه وجود داشته باشد، نیازی به بررسی نیست
			if (monthData.length < 2) {
				return false;
			}
			
			// تاریخ‌ها را بر اساس روز ماه مرتب می‌کنیم
			monthData.sort((a, b) => a.day - b.day);

			// اولین تاریخ را به عنوان مبدأ در نظر می‌گیریم
			const firstDate = monthData[0];
			const firstDayNum = dayOfWeekMap[firstDate.dayOfWeek];

			// بقیه تاریخ‌ها را با اولین تاریخ مقایسه می‌کنیم
			for (let i = 1; i < monthData.length; i++) {
				const currentDate = monthData[i];
				const currentDayNum = dayOfWeekMap[currentDate.dayOfWeek];

				// محاسبه اختلاف روزهای ماه و روزهای هفته
				const dayDifference = currentDate.day - firstDate.day;
				const dayOfWeekDifference = (currentDayNum - firstDayNum + 7) % 7;

				// اگر اختلاف روزها با اختلاف روزهای هفته منطبق نباشد، تأیید نمی‌شوند
				if (dayDifference % 7 !== dayOfWeekDifference) {
					return false;
				}
			}

			// اگر همه تاریخ‌ها منطبق باشند، تأیید می‌شوند
			return true;
		}

		function generateReport() {
			const dataInput = document.getElementById('dataInput').value;
			const lines = dataInput.trim().split('\n');
			
			const detectedData = new Set();
			const consecutiveMonths = new Set();
			const innerConsecutiveMonths = new Set();
			const confirmedMonths = new Set();
			
			// یک شی برای نگهداری تمام تاریخ‌های هر ماه
			const allMonthDates = {};

			lines.forEach(line => {
				const parts = line.trim().split(/\s+/);
				if (parts.length >= 2) {
					const datePart = parts[0];
					const dayOfWeekPart = parts[1];
					const dateSegments = datePart.split('-');
					if (dateSegments.length === 3) {
						const year = parseInt(dateSegments[0], 10);
						const month = parseInt(dateSegments[1], 10);
						const day = parseInt(dateSegments[2], 10);
						// سال‌ها باید بین 500 تا 1299 باشند و ماه‌ها بین 1 تا 12
						if (!isNaN(year) && !isNaN(month) && !isNaN(day) && year >= 500 && year <= 1299 && month >= 1 && month <= 12) {
							const key = `${year}-${month}`;
							detectedData.add(key);

							if (!allMonthDates[key]) {
								allMonthDates[key] = [];
							}
							allMonthDates[key].push({ day: day, dayOfWeek: dayOfWeekPart });
						}
					}
				}
			});

			const minYear = 500;
			const maxYear = 1299;
			const numYears = maxYear - minYear + 1;

			// شناسایی ماه های متوالی و ماه های میانی متوالی و ماه های تأیید شده
			for (let year = minYear; year <= maxYear; year++) {
				let currentSequence = [];
				for (let month = 1; month <= 12; month++) {
					const key = `${year}-${month}`;

					// بررسی ماه های تأیید شده
					if (allMonthDates[key] && checkMonthForConfirmation(allMonthDates[key])) {
						confirmedMonths.add(key);
					}

					if (detectedData.has(key)) {
						currentSequence.push(key);
					} else {
						// پردازش دنباله ای که همین الان به پایان رسید
						if (currentSequence.length >= 2) {
							currentSequence.forEach(mKey => consecutiveMonths.add(mKey));
						}
						if (currentSequence.length >= 3) {
							// اضافه کردن ماه های میانی به مجموعه innerConsecutiveMonths
							for (let i = 1; i < currentSequence.length - 1; i++) {
								innerConsecutiveMonths.add(currentSequence[i]);
							}
						}
						currentSequence = []; // بازنشانی برای دنباله بعدی
					}
				}
				// پردازش هر دنباله باقی مانده در پایان سال
				if (currentSequence.length >= 2) {
					currentSequence.forEach(mKey => consecutiveMonths.add(mKey));
				}
				if (currentSequence.length >= 3) {
					for (let i = 1; i < currentSequence.length - 1; i++) {
						innerConsecutiveMonths.add(currentSequence[i]);
					}
				}
			}

			const totalPossibleCells = numYears * 12;
			const greenCellsCount = detectedData.size;

			const summaryContainer = document.getElementById('summaryContainer');
			let summaryHtml = `
				<p class="text-lg font-semibold text-gray-800">
					کسر ماه‌های دارای داده: ${greenCellsCount}/${totalPossibleCells}
				</p>
				<p class="text-lg font-semibold text-gray-800">
					درصد ماه‌های دارای داده: ${((greenCellsCount / totalPossibleCells) * 100).toFixed(2)}%
				</p>
			`;
			summaryContainer.innerHTML = summaryHtml;

			const canvas = document.getElementById('dataCanvas');
			const ctx = canvas.getContext('2d');
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			const numRows = 8;
			const yearsPerRow = numYears / numRows; // 800 / 8 = 100 years per row
			const pixelsPerUnit = 4; // هر ماه یک پیکسل 4x4 است

			// تنظیم ابعاد بوم بر اساس طرح جدید
			canvas.width = yearsPerRow * pixelsPerUnit; // 100 * 4 = 400
			canvas.height = numRows * 12 * pixelsPerUnit; // 8 * 12 * 4 = 384

			for (let year = minYear; year <= maxYear; year++) {
				const totalYearIndex = year - minYear; // 0 تا 799
				const row = Math.floor(totalYearIndex / yearsPerRow);
				const yearInRowIndex = totalYearIndex % yearsPerRow;

				for (let month = 1; month <= 12; month++) {
					const key = `${year}-${month}`;
					// اولویت‌بندی جدید بر اساس منطق دقت
					if (confirmedMonths.has(key) && innerConsecutiveMonths.has(key)) {
						ctx.fillStyle = '#00008B'; // آبی سیر
					} else if (confirmedMonths.has(key)) {
						ctx.fillStyle = '#00FFFF'; // آبی فیروزه‌ای
					} else if (innerConsecutiveMonths.has(key)) {
						ctx.fillStyle = '#090'; // سبز
					} else if (consecutiveMonths.has(key)) {
						ctx.fillStyle = '#FFA500'; // نارنجی
					} else if (detectedData.has(key)) {
						ctx.fillStyle = '#FFCCCC'; // قرمز کمرنگ
					} else {
						ctx.fillStyle = '#ffffff'; // سفید
					}
					// محاسبه مختصات x و y برای بلوک های پیکسلی 4x4
					const x = yearInRowIndex * pixelsPerUnit;
					const y = (row * 12 * pixelsPerUnit) + ((month - 1) * pixelsPerUnit);
					ctx.fillRect(x, y, pixelsPerUnit, pixelsPerUnit);
				}
			}

			const reportContainer = document.getElementById('reportContainer');
			let tableHtml = `
				<table class="min-w-full bg-white rounded-lg shadow-md">
					<thead>
						<tr>
							<th class="rounded-tr-lg">سال قمری</th>
							${Array.from({ length: 12 }, (_, i) => `<th class="${i === 11 ? 'rounded-tl-lg' : ''}">ماه ${i + 1}</th>`).join('')}
						</tr>
					</thead>
					<tbody>
			`;

			for (let year = minYear; year <= maxYear; year++) {
				tableHtml += `<tr><td class="font-semibold">${year}</td>`;
				for (let month = 1; month <= 12; month++) {
					const key = `${year}-${month}`;
					let cellClass = '';
					// اولویت‌بندی جدید بر اساس منطق دقت
					if (confirmedMonths.has(key) && innerConsecutiveMonths.has(key)) {
						cellClass = 'confirmed-and-inner-consecutive-highlighted'; // آبی سیر
					} else if (confirmedMonths.has(key)) {
						cellClass = 'confirmed-highlighted'; // آبی فیروزه‌ای
					} else if (innerConsecutiveMonths.has(key)) {
						cellClass = 'inner-consecutive-highlighted'; // سبز
					} else if (consecutiveMonths.has(key)) {
						cellClass = 'consecutive-highlighted'; // نارنجی
					} else if (detectedData.has(key)) {
						cellClass = 'highlighted'; // قرمز کمرنگ
					}
					tableHtml += `<td class="${cellClass}"></td>`;
				}
				tableHtml += `</tr>`;
			}

			tableHtml += `
					</tbody>
				</table>
			`;

			reportContainer.innerHTML = tableHtml;
		}

		window.onload = generateReport;
	</script>
</body>
</html>
